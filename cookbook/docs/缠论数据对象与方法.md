## 缠论数据对象与方法

---

### 原始K线对象（Kline）

属性值

> * `index` ：索引，可以快速通过K线对象，找到它前后的k线对象
> * `date` ：K线时间，datetime对象
> * `h` ：最高价格
> * `l` ：最低价格
> * `o` ：开盘价格
> * `c` ：收盘价格
> * `a` ：成交量

### 合并处理后的缠论K线对象（CLKline）

属性值

> * `k_index` ：包含处理后，最高/最低 那根原始K线的索引值
> * `index` ：缠论K线索引值
> * `date` ：缠论K线时间，datetime对象
> * `h` ：最高价格
> * `l` ：最低价格
> * `o` ：开盘价格
> * `c` ：收盘价格
> * `a` ：成交量 （包含的所有K线的成交量总和）
> * `klines`：包含的原始K线对象列表
> * `n`：包含的K线数量
> * `q`：弃用了
> * `up_qs` : 合并前两根缠论K线的趋势（向上 or 向下）

### 分型对象（FX）

属性值

> * `index`：分型索引
> * `type` ：分型类型，ding 顶分型 di 底分型
> * `k` ：分型中间的缠论K线对象
> * `klines`：组成分型的三个缠论K线列表
> * `val`：分型 顶、低 的值
> * `done`：分型是否完成，未完成的分型中，klines 对象中只有两根缠论K线

方法

> * `ld()`: 根据规则，返回分型的力度值，数值越大表示力度越大
> * `high(qj_type)`: 按照给定的分型区间配置值，返回分型的最高值
> * `low(qj_type)`: 按照给定的分型区间配置值，返回分型的最低值

### 笔对象（BI）

属性值

> * `index`：笔索引值
> * `start`：起始分型对象
> * `end`：结束分型对象
> * `high`：笔的最高值
> * `low`：笔的最低值
> * `type`：笔的方向（up 向上笔、down 向下笔）
> * `mmds`：笔的买卖点对象列表
> * `bcs`：笔的背驰对象列表
> * `td`：~~笔是否停顿，废弃，建议使用 cl_utils.py 中的 bi_td 方法判断~~
> * `zs_type_mmds`：不同中枢类型下的买卖点对象列表
> * `zs_type_bcs`：不同中枢类型下的背驰对象列表

方法

> * `is_done()`: 返回笔是否完成
> * `fx_num()`: 返回笔中包含的分型数量
> * `get_mmds(zs_type)`: 返回笔中买卖点列表，可传递 zs_type 返回指定的中枢类型的买卖点
> * `get_bcs(zs_type)`: 返回笔中背驰列表，可传递 zs_type 返回指定的中枢类型的背驰
> * `add_mmd(...)`: 增加笔的买卖点信息
> * `add_bc(...)`: 增加笔的背驰信息
> * `line_mmds(zs_type)`: 返回笔的买卖点名称列表，可传递 zs_type 返回指定的中枢类型的买卖点列表，zs_type 可以取值 |、& 来索取当前计算的所有中枢买卖点的合集和交集
> * `line_bcs(zs_type)`: 返回笔的背驰名称列表，可传递 zs_type 返回指定的中枢类型的背驰列表，zs_type 可以取值 |、& 来索取当前计算的所有中枢背驰的合集和交集
> * `mmd_exists(check_mmds, zs_type)`: 判断笔中是否存在给定的买卖点中的一个
> * `bc_exists(bc_types, zs_type)`: 判断笔中是否存在给定的背驰中的一个
> * `get_ld()`: 返回笔的力度信息（MACD 相关信息）
> * `jiaodu()`: 返回笔与固定坐标轴的夹角角度

### 线段对象（XD）

属性值

> * `index`：线段索引值
> * `start`：起始分型对象
> * `end`：结束分型对象
> * `start_line`：起始的线（笔、线段）对象
> * `end_line`：结束的线（笔、线段）对象
> * `high`：线段的最高值
> * `low`：线段的最低值
> * `type`：线段的方向（up 向上笔、down 向下笔）
> * `mmds`：线段的买卖点对象列表
> * `bcs`：线段的背驰对象列表
> * `zs_type_mmds`：不同中枢类型下的买卖点对象列表
> * `zs_type_bcs`：不同中枢类型下的背驰对象列表
> * `ding_fx`：特征序列顶分型对象
> * `di_fx`：特征序列底分型对象

方法

> * `is_done()`: 返回线段是否完成
> * `is_qk()`: 成线段的结束特征序列分型是否有缺口
> * `get_mmds(zs_type)`: 返回线段中买卖点列表，可传递 zs_type 返回指定的中枢类型的买卖点
> * `get_bcs(zs_type)`: 返回线段中背驰列表，可传递 zs_type 返回指定的中枢类型的背驰
> * `add_mmd(...)`: 增加线段的买卖点信息
> * `add_bc(...)`: 增加线段的背驰信息
> * `line_mmds(zs_type)`: 返回线段的买卖点名称列表，可传递 zs_type 返回指定的中枢类型的买卖点列表，zs_type 可以取值 |、& 来索取当前计算的所有中枢买卖点的合集和交集
> * `line_bcs(zs_type)`: 返回线段的背驰名称列表，可传递 zs_type 返回指定的中枢类型的背驰列表，zs_type 可以取值 |、& 来索取当前计算的所有中枢背驰的合集和交集
> * `mmd_exists(check_mmds, zs_type)`: 判断笔中是否存在给定的买卖点中的一个
> * `bc_exists(bc_types, zs_type)`: 判断笔中是否存在给定的背驰中的一个
> * `get_ld()`: 返回线段的力度信息（MACD 相关信息）
> * `jiaodu()`: 返回线段与固定坐标轴的夹角角度

### 中枢对象（ZS）

属性值

> * `index`：中枢索引值
> * `zs_type`：中枢的类型（bi 笔中枢、xd 线段中枢、zsd 走时段中枢）
> * `start`：中枢起始的分型对象
> * `end`：中枢结束的分型对象
> * `lines`：组成中枢的线（笔、线段）列表，包括进入与离开段
> * `zg`：中枢高点，前三笔重叠区域的高点
> * `zd`：中枢低点，前三笔重叠区域的低点
> * `gg`：中枢高高点，中枢重叠区域最高点
> * `dd`：中枢低低点，中枢重叠区域最低点
> * `type`：中枢的方向类型（up 上涨中枢、down 下跌中枢、zd 震荡中枢（无方向））
> * `line_num`：中枢重叠区域线的数量
> * `level`：中枢级别，起始为 0，每9笔升一级
> * `done`：记录中枢是否完成（出现三类买卖点则中枢完成）
> * `real`：中枢是否有效（根据计算的中枢类型，在一些情况下之前计算的中枢会作废，重新画新的中枢）

方法

> * `zf()`: 中枢振幅，中枢重叠区间占整个中枢区间的百分比，越大说明中枢重叠区域外的波动越小
> * `zs_mmds()`: 获取中枢内线的所有买点列表

### 买卖点对象（MMD）

属性值

> * `name`: 买卖点名称，如（1buy、2buy、3buy、l3buy、1sell、2sell、3sell、l3sell）
> * `zs`: 买卖点对应的中枢对象，有中枢才有买卖点，如因为中枢计算方式，导致中枢无效重画，但是原来的买卖点依然存在，这里依然可以找到买卖点对应的中枢信息
> * `msg`: 买卖点信息，这个目前没有用到

### 背驰对象（BC）

属性值

> * `type`: 背驰类型，（bi 笔背驰 xd 线段背驰 zsd 走势段背驰 pz 盘整背驰 qs 趋势背驰）
> * `zs`: 背驰对应的中枢对象，只有 pz、qs 背驰类型才有中枢对象
> * `compare_line`: 与之比较的线对象，bi、xd、zsd 背驰才有，分别对应的线为 笔、线段、走时段（线段）
> * `compare_lines`: 与之比较的线列表对象，在趋势背驰时有值，aAbBc 类型的趋势背驰，b对应的可能不是一笔
> * `bc`: 标记是否背驰，True 背驰 False 没有背驰

### 缠论数据计算对象接口类（ICL）

方法

> * `ICL(code: str, frequency: str, config: Union[dict, None] = None)`
    >
    >       初始化方法，传递 `code` 计算的标的代码， `frequency` 周期，`config` 使用的缠论配置项
>
> * `process_klines(klines: pd.DataFrame)`
    >
    >       计算k线缠论数据，并返回当前缠论数据对象
    >       传递 pandas 数据，需要包括以下列：
    >           date 时间日期 datetime 格式，对于在 DataFrame 中 date 不是日期格式的，需要执行 pd.to_datetime 方法转换下
    >           high 最高价
    >           low 最低价
    >           open 开盘价
    >           close 收盘价
    >           volume 成交量
    >       
    >       可增量多次调用，重复已计算的会自动跳过，最后一个 bar 会进行更新
>
> * `get_code()`
    >
    >       返回计算的标的代码
>
> * `get_frequency()`
    >
    >       返回计算的周期参数
>
> * `get_config()`
    >
    >       返回计算的缠论配置对象
>
> * `get_src_klines()`
    >
    >       返回原始的K线对象列表
> 
> * `get_klines()`
    >
    >        如果 kline_type == kline_default 则返回原始 K 线数据
    >
    >        如果 kline_type == kline_heikin_ashi 则返回经过处理后的平均K线数据，如需获取原始K线数据，使用 get_src_klines 方法
>
> * `get_cl_klines()`
    >
    >       返回包含合并后的缠论K线列表
>
> * `get_idx()`
    >
    >       返回内部计算的指标数据，目前只有 macd 指标，其他指标在外部进行计算
>
> * `get_fxs()`
    >
    >       返回缠论分型对象列表
>
> * `get_bis()`
    >
    >       返回笔对象列表
>
> * `get_xds()`
    >
    >       返回线段对象列表
>
> * `get_zsds()`
    >
    >       返回走时段对象列表，这里是计算的走势段，数据对象类型使用的是 XD 对象，和线段的计算方式一样，线段使用的是笔的特征序列，走势段使用的是线段的特征序列
>
> * `get_bi_zss(zs_type)`
    >
    >       返回笔的中枢对象列表；
    >       可传递 zs_type，返回指定的中枢类型下的中枢对象;
    >       前提是在 config 的 zs_bi_type 配置项设置多个笔中枢类型，如 ['zs_type_bz', 'zs_type_fx']
    >       zs_type 为 None，默认返回第一个设置的中枢类型的中枢对象
>
> * `get_xd_zss(zs_type)`
    >
    >       返回线段的中枢对象列表；
    >       可传递 zs_type，返回指定的中枢类型下的中枢对象;
    >       前提是在 config 的 zs_xd_type 配置项设置多个笔中枢类型，如 ['zs_type_bz', 'zs_type_fx']
    >       zs_type 为 None，默认返回第一个设置的中枢类型的中枢对象
>
> * `get_zsd_zss()`
    >
    >       返回走势段的中枢对象列表；走势段的中枢类型只有标准中枢类型的
>
> * `get_last_bi_zs()`
    >
    >       返回最后的笔中枢，根据最后几笔倒推出的笔中枢，和 self.get_bi_zss()[-1] 方式获取的中枢不一定一致
>
> * `get_last_xd_zs()`
    >
    >       返回最后的线段中枢，根据最后线段倒推出的线段中枢，和 self.get_xd_zss()[-1] 方式获取的中枢不一定一致
>
> * `create_dn_zs(zs_type, lines)`
    >
    >       这里的 zs_type 指的是中枢类型，bi 笔中枢、xd 线段中枢（和其他参数同名但是意义不同。。。懒得改了）
    >       根据给定的线列表，按照中枢计算规则，计算并返回生成的中枢列表
>
> * `beichi_pz(zs, now_line)`
    >
    >       判断中枢与指定线是否构成盘整背驰
>
> * `beichi_qs(lines, zss, now_line)`
    >
    >       判断指定线与之前的中枢，是否形成了趋势背驰
>
> * `compare_ld_beichi(one_ld, two_ld, hist_type)`
    >
    >       比较两个力度，后者小于前者，返回 True
    >       hist_type：[up, down] up 统计 macd 的红柱子之和，down 统计 macd 绿柱子之和
>
> * `zss_is_qs(one_zs, two_zs)`
    >
    >       判断两个中枢是否形成趋势（根据设置的位置关系配置，来判断两个中枢是否有重叠）
>
